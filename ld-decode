#!/usr/bin/env python3
from base64 import b64encode
import copy
from datetime import datetime
import getopt
import io
from io import BytesIO
import logging
import os
import signal
import subprocess
import sys
import argparse
import json
import traceback

from multiprocessing import Process, Pool, Queue, JoinableQueue, Pipe
import threading
import queue

from lddecode.core import *
from lddecode.utils import *
from lddecode.utils_logging import init_logging

options_epilog = """FREQ can be a bare number in MHz, or a number with one of the case-insensitive suffixes Hz, kHz, MHz, GHz, fSC (meaning NTSC) or fSCPAL."""
parser = argparse.ArgumentParser(
    description="Extracts audio and video from raw RF laserdisc captures",
    epilog=options_epilog,
)
parser.add_argument("infile", metavar="infile", type=str, help="source file")
parser.add_argument(
    "outfile", metavar="outfile", type=str, help="base name for destination files"
)
parser.add_argument(
    "--start",
    "-s",
    dest="start",
    metavar="file-location",
    type=float,
    default=0,
    help="rough jump to frame n of capture (default is 0)",
)
parser.add_argument(
    "--length",
    "-l",
    dest="length",
    metavar="frames",
    type=int,
    default=110000,
    help="limit length to n frames",
)
parser.add_argument(
    "--seek",
    "-S",
    dest="seek",
    metavar="frame",
    type=int,
    default=-1,
    help="seek to frame n of capture",
)
# parser.add_argument('-E', '--end', metavar='end', type=int, default=-1, help='cutting: last frame')
parser.add_argument(
    "--PAL",
    "-p",
    "--pal",
    dest="pal",
    action="store_true",
    help="source is in PAL format",
)
parser.add_argument(
    "--NTSC", "-n", "--ntsc", dest="ntsc", action="store_true", help="source is in NTSC format"
)
parser.add_argument(
    "--NTSCJ",
    "-j",
    dest="ntscj",
    action="store_true",
    help="source is in NTSC-J (IRE 0 black) format",
)
# parser.add_argument('-c', '--cut', dest='cut', action='store_true', help='cut (to r16) instead of decode')
parser.add_argument(
    "-m",
    "--MTF",
    metavar="mtf",
    type=float,
    default=None,
    help="mtf compensation multiplier",
)
parser.add_argument(
    "--MTF_offset",
    metavar="mtf_offset",
    type=float,
    default=None,
    help="mtf compensation offset",
)
parser.add_argument(
    "--noAGC", dest="noAGC", action="store_true", default=False, help="Disable AGC"
)
parser.add_argument(
    "--noDOD",
    dest="nodod",
    action="store_true",
    default=False,
    help="disable dropout detector",
)
parser.add_argument(
    "--noEFM",
    dest="noefm",
    action="store_true",
    default=False,
    help="Disable EFM front end",
)
parser.add_argument(
    "--preEFM",
    dest="prefm",
    action="store_true",
    default=False,
    help="Write filtered but otherwise pre-processed EFM data",
)
parser.add_argument(
    "--disable_analog_audio",
    "--disable_analogue_audio",
    "--daa",
    dest="daa",
    action="store_true",
    default=False,
    help="Disable analog(ue) audio decoding",
)
parser.add_argument(
    "--start_fileloc",
    metavar="start_fileloc",
    type=float,
    default=-1,
    help="jump to precise sample # in the file",
)
parser.add_argument(
    "--ignoreleadout",
    dest="ignoreleadout",
    action="store_true",
    default=False,
    help="continue decoding after lead-out seen",
)
parser.add_argument(
    "--verboseVITS",
    dest="verboseVITS",
    action="store_true",
    default=False,
    help="Enable additional JSON fields",
)

parser.add_argument(
    "--RF_TBC",
    dest="RF_TBC",
    action="store_true",
    default=False,
    help="Create a .tbc.ldf file with TBC'd RF",
)

parser.add_argument(
    "--lowband",
    dest="lowband",
    action="store_true",
    default=False,
    help="Use more restricted RF settings for noisier disks",
)

parser.add_argument(
    "--NTSC_color_notch_filter",
    dest="NTSC_color_notch_filter",
    action="store_true",
    default=False,
    help="Mitigate interference from analog audio in reds in NTSC captures",
)
parser.add_argument(
    "--V4300D_notch_filter",
    dest="V4300D_notch_filter",
    action="store_true",
    default=False,
    help="LD-V4300D PAL/digital audio captures: remove spurious ~8.5mhz signal",
)

parser.add_argument(
    "-d",
    "--deemp_adjust",
    metavar="deemp_adjust",
    type=float,
    default=1.0,
    help="Deemphasis level multiplier",
)
parser.add_argument(
    "--deemp_low",
    metavar="deemp_low",
    type=float,
    default=0,
    help="Deemphasis low coefficient",
)
parser.add_argument(
    "--deemp_high",
    metavar="deemp_high",
    type=float,
    default=0,
    help="Deemphasis high coefficient",
)

parser.add_argument(
    "-t",
    "--threads",
    metavar="threads",
    type=int,
    default=5,
    help="number of CPU threads to use",
)

parser.add_argument(
    "-f",
    "--frequency",
    dest="inputfreq",
    metavar="FREQ",
    type=parse_frequency,
    default=None,
    help="RF sampling frequency in source file (default is 40MHz)",
)

parser.add_argument(
    "--video_bpf_high",
    dest="vbpf_high",
    metavar="FREQ",
    type=parse_frequency,
    default=None,
    help="Video BPF high end frequency",
)
parser.add_argument(
    "--video_lpf",
    dest="vlpf",
    metavar="FREQ",
    type=parse_frequency,
    default=None,
    help="Video low-pass filter frequency",
)
parser.add_argument(
    "--video_lpf_order",
    dest="vlpf_order",
    type=int,
    default=-1,
    help="Video low-pass filter order",
)
parser.add_argument(
    "--new-audio",
    dest="newaudio",
    action="store_true",
    #type=bool,
    default=False,
    help="Use new audio code (will save to [output]-n.*",
)

args = parser.parse_args()
# print(args)
filename = args.infile
outname = args.outfile
firstframe = args.start
req_frames = args.length
vid_standard = "PAL" if args.pal else "NTSC"

if args.pal and (args.ntsc or args.ntscj):
    print("ERROR: Can only be PAL or NTSC")
    exit(1)

audio_pipe = None

if args.newaudio:
    spath = os.path.dirname(os.path.realpath(__file__))
    cmd = [os.path.join(spath, 'lddecode', 'audio.py'), 
           '-i', '-',
           '-o', outname + '-n']

    if args.daa:
        cmd.append('--daa')

    if args.pal:
        cmd.append('--PAL')

    if args.prefm:
        cmd.append('--preEFM')

    if args.noefm:
        cmd.append('--noEFM')

    if False: # Flip this around when it becomes the default, remove when only
        args.daa = True
        args.noefm = True
        args.prefm = False

    audio_process = subprocess.Popen(cmd, stdin=subprocess.PIPE)
    if audio_process is None:
        print("ERROR: unable to open audio subprocess")

    audio_pipe = audio_process.stdin

extra_options = {
    "useAGC": not args.noAGC,
    "write_RF_TBC": args.RF_TBC,
    "pipe_RF_TBC": audio_pipe,
    "write_pre_efm": args.prefm,
    "deemp_mult": (args.deemp_adjust, args.deemp_adjust),
    "deemp_coeff": (args.deemp_low, args.deemp_high),
}

if vid_standard == "NTSC" and args.NTSC_color_notch_filter:
    extra_options["NTSC_ColorNotchFilter"] = True

if vid_standard == "PAL" and args.V4300D_notch_filter:
    extra_options["PAL_V4300D_NotchFilter"] = True

if args.lowband:
    extra_options["lowband"] = True

try:
    loader = make_loader(filename, args.inputfreq)
except ValueError as e:
    print(e)
    exit(1)

system = "PAL" if args.pal else "NTSC"

# Wrap the LDdecode creation so that the signal handler is not taken by sub-threads,
# allowing SIGINT/control-C's to be handled cleanly
original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)

logger = init_logging(outname + ".log")
ldd = LDdecode(
    filename,
    outname,
    loader,
    logger,
    est_frames=req_frames,
    analog_audio=0 if args.daa else 44.100,
    digital_audio=not args.noefm,
    system=system,
    doDOD=not args.nodod,
    threads=args.threads,
    extra_options=extra_options,
)

signal.signal(signal.SIGINT, original_sigint_handler)

if args.start_fileloc != -1:
    ldd.roughseek(args.start_fileloc, False)
else:
    ldd.roughseek(firstframe * 2)

if system == "NTSC" and not args.ntscj:
    ldd.blackIRE = 7.5

# print(ldd.blackIRE)

if args.seek != -1:
    if ldd.seek(args.seek if firstframe == 0 else firstframe, args.seek) is None:
        print("ERROR: Seeking failed", file=sys.stderr)
        exit(1)

if args.MTF is not None:
    ldd.rf.mtf_mult = args.MTF

if args.MTF_offset is not None:
    ldd.rf.mtf_offset = args.MTF_offset

DecoderParamsOverride = {}
if args.vbpf_high is not None:
    DecoderParamsOverride["video_bpf_high"] = args.vbpf_high * 1000000

if args.vlpf is not None:
    DecoderParamsOverride["video_lpf_freq"] = args.vlpf * 1000000

if args.vlpf_order >= 1:
    DecoderParamsOverride["video_lpf_order"] = args.vlpf_order

if len(DecoderParamsOverride.keys()):
    ldd.demodcache.setparams(DecoderParamsOverride)

if args.verboseVITS:
    ldd.verboseVITS = True

done = False

jsondumper = jsondump_thread(ldd, outname)

def cleanup():
    jsondumper.put(ldd.build_json(ldd.curfield))
    # logger.flush()
    ldd.close()
    jsondumper.put(None)
    if audio_pipe is not None:
        audio_pipe.close()


while not done and ldd.fields_written < (req_frames * 2):
    try:
        f = ldd.readfield()
    except KeyboardInterrupt as kbd:
        print("\nTerminated, saving JSON and exiting", file=sys.stderr)
        cleanup()
        exit(1)
    except Exception as err:
        print(
            "\nERROR - please paste the following into a bug report:", file=sys.stderr
        )
        print("current sample:", ldd.fdoffset, file=sys.stderr)
        print("arguments:", args, file=sys.stderr)
        print("Exception:", err, " Traceback:", file=sys.stderr)
        traceback.print_tb(err.__traceback__)
        cleanup()
        exit(1)

    if f is None or (args.ignoreleadout == False and ldd.leadOut == True):
        done = True

    if ldd.fields_written < 100 or ((ldd.fields_written % 500) == 0):
        jsondumper.put(ldd.build_json(ldd.curfield))

print("\nCompleted: saving JSON and exiting", file=sys.stderr)
cleanup()
